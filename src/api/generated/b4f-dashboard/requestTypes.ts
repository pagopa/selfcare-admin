// DO NOT EDIT THIS FILE
// This file has been generated by gen-api-models
// eslint-disable sonar/max-union-size
// eslint-disable sonarjs/no-identical-functions

import * as t from "io-ts";

import * as r from "@pagopa/ts-commons/lib/requests";

import { InstitutionResourceArray } from "./InstitutionResourceArray";

import { Problem } from "./Problem";

import { InstitutionResource } from "./InstitutionResource";

import { ProductsResourceArray } from "./ProductsResourceArray";

import { ProductUserResourceArray } from "./ProductUserResourceArray";

import { CreateUserDto } from "./CreateUserDto";

import { UserIdResource } from "./UserIdResource";

import { UserProductRoles } from "./UserProductRoles";

import { InstitutionUserResourceArray } from "./InstitutionUserResourceArray";

import { InstitutionUserDetailsResource } from "./InstitutionUserDetailsResource";

import { ProductRoleMappingsResourceArray } from "./ProductRoleMappingsResourceArray";

import { IdentityTokenResource } from "./IdentityTokenResource";

import { PageOfUserGroupPlainResource } from "./PageOfUserGroupPlainResource";

import { CreateUserGroupDto } from "./CreateUserGroupDto";

import { UserGroupIdResource } from "./UserGroupIdResource";

import { UserGroupResource } from "./UserGroupResource";

import { UpdateUserGroupDto } from "./UpdateUserGroupDto";

import { UserDto } from "./UserDto";

import { SearchUserDto } from "./SearchUserDto";

import { UserResource } from "./UserResource";

import { UpdateUserDto } from "./UpdateUserDto";

/****************************************************************
 * getInstitutionsUsingGET
 */

// Request type definition
export type GetInstitutionsUsingGETT = r.IGetApiRequestType<
  { readonly bearerAuth: string },
  "Authorization",
  never,
  | r.IResponseType<200, InstitutionResourceArray, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<404, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const getInstitutionsUsingGETDefaultResponses = {
  200: InstitutionResourceArray,
  400: Problem,
  401: Problem,
  404: Problem,
  500: Problem
};

export type GetInstitutionsUsingGETResponsesT<
  A0 = InstitutionResourceArray,
  C0 = InstitutionResourceArray,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  404: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function getInstitutionsUsingGETDecoder<
  A0 = InstitutionResourceArray,
  C0 = InstitutionResourceArray,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
>(
  overrideTypes:
    | Partial<
        GetInstitutionsUsingGETResponsesT<
          A0,
          C0,
          A1,
          C1,
          A2,
          C2,
          A3,
          C3,
          A4,
          C4
        >
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<404, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getInstitutionsUsingGETDefaultResponses as unknown) as GetInstitutionsUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
      d404
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const getInstitutionsUsingGETDefaultDecoder = () =>
  getInstitutionsUsingGETDecoder();

/****************************************************************
 * getInstitutionUsingGET
 */

// Request type definition
export type GetInstitutionUsingGETT = r.IGetApiRequestType<
  { readonly bearerAuth: string; readonly institutionId: string },
  "Authorization",
  never,
  | r.IResponseType<200, InstitutionResource, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<404, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const getInstitutionUsingGETDefaultResponses = {
  200: InstitutionResource,
  400: Problem,
  401: Problem,
  404: Problem,
  500: Problem
};

export type GetInstitutionUsingGETResponsesT<
  A0 = InstitutionResource,
  C0 = InstitutionResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  404: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function getInstitutionUsingGETDecoder<
  A0 = InstitutionResource,
  C0 = InstitutionResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
>(
  overrideTypes:
    | Partial<
        GetInstitutionUsingGETResponsesT<A0, C0, A1, C1, A2, C2, A3, C3, A4, C4>
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<404, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getInstitutionUsingGETDefaultResponses as unknown) as GetInstitutionUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
      d404
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const getInstitutionUsingGETDefaultDecoder = () =>
  getInstitutionUsingGETDecoder();

/****************************************************************
 * saveInstitutionLogoUsingPUT
 */

// Request type definition
export type SaveInstitutionLogoUsingPUTT = r.IPutApiRequestType<
  {
    readonly bearerAuth: string;
    readonly institutionId: string;
    readonly logo: File;
  },
  "Content-Type" | "Authorization",
  never,
  | r.IResponseType<200, undefined, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const saveInstitutionLogoUsingPUTDefaultResponses = {
  200: t.undefined,
  400: Problem,
  401: Problem,
  500: Problem
};

export type SaveInstitutionLogoUsingPUTResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  500: t.Type<A3, C3>;
};

export function saveInstitutionLogoUsingPUTDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
>(
  overrideTypes:
    | Partial<
        SaveInstitutionLogoUsingPUTResponsesT<A0, C0, A1, C1, A2, C2, A3, C3>
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<500, A3, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((saveInstitutionLogoUsingPUTDefaultResponses as unknown) as SaveInstitutionLogoUsingPUTResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A3, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const saveInstitutionLogoUsingPUTDefaultDecoder = () =>
  saveInstitutionLogoUsingPUTDecoder();

/****************************************************************
 * getInstitutionProductsUsingGET
 */

// Request type definition
export type GetInstitutionProductsUsingGETT = r.IGetApiRequestType<
  { readonly bearerAuth: string; readonly institutionId: string },
  "Authorization",
  never,
  | r.IResponseType<200, ProductsResourceArray, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<404, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const getInstitutionProductsUsingGETDefaultResponses = {
  200: ProductsResourceArray,
  400: Problem,
  401: Problem,
  404: Problem,
  500: Problem
};

export type GetInstitutionProductsUsingGETResponsesT<
  A0 = ProductsResourceArray,
  C0 = ProductsResourceArray,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  404: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function getInstitutionProductsUsingGETDecoder<
  A0 = ProductsResourceArray,
  C0 = ProductsResourceArray,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
>(
  overrideTypes:
    | Partial<
        GetInstitutionProductsUsingGETResponsesT<
          A0,
          C0,
          A1,
          C1,
          A2,
          C2,
          A3,
          C3,
          A4,
          C4
        >
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<404, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getInstitutionProductsUsingGETDefaultResponses as unknown) as GetInstitutionProductsUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
      d404
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const getInstitutionProductsUsingGETDefaultDecoder = () =>
  getInstitutionProductsUsingGETDecoder();

/****************************************************************
 * getInstitutionProductUsersUsingGET
 */

// Request type definition
export type GetInstitutionProductUsersUsingGETT = r.IGetApiRequestType<
  {
    readonly bearerAuth: string;
    readonly institutionId: string;
    readonly productId: string;
    readonly role?: string;
    readonly productRoles?: string;
  },
  "Authorization",
  never,
  | r.IResponseType<200, ProductUserResourceArray, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<404, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const getInstitutionProductUsersUsingGETDefaultResponses = {
  200: ProductUserResourceArray,
  400: Problem,
  401: Problem,
  404: Problem,
  500: Problem
};

export type GetInstitutionProductUsersUsingGETResponsesT<
  A0 = ProductUserResourceArray,
  C0 = ProductUserResourceArray,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  404: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function getInstitutionProductUsersUsingGETDecoder<
  A0 = ProductUserResourceArray,
  C0 = ProductUserResourceArray,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
>(
  overrideTypes:
    | Partial<
        GetInstitutionProductUsersUsingGETResponsesT<
          A0,
          C0,
          A1,
          C1,
          A2,
          C2,
          A3,
          C3,
          A4,
          C4
        >
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<404, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getInstitutionProductUsersUsingGETDefaultResponses as unknown) as GetInstitutionProductUsersUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
      d404
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const getInstitutionProductUsersUsingGETDefaultDecoder = () =>
  getInstitutionProductUsersUsingGETDecoder();

/****************************************************************
 * createInstitutionProductUserUsingPOST
 */

// Request type definition
export type CreateInstitutionProductUserUsingPOSTT = r.IPostApiRequestType<
  {
    readonly bearerAuth: string;
    readonly institutionId: string;
    readonly productId: string;
    readonly body?: CreateUserDto;
  },
  "Content-Type" | "Authorization",
  never,
  | r.IResponseType<201, UserIdResource, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const createInstitutionProductUserUsingPOSTDefaultResponses = {
  201: UserIdResource,
  400: Problem,
  401: Problem,
  500: Problem
};

export type CreateInstitutionProductUserUsingPOSTResponsesT<
  A0 = UserIdResource,
  C0 = UserIdResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
> = {
  201: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  500: t.Type<A3, C3>;
};

export function createInstitutionProductUserUsingPOSTDecoder<
  A0 = UserIdResource,
  C0 = UserIdResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
>(
  overrideTypes:
    | Partial<
        CreateInstitutionProductUserUsingPOSTResponsesT<
          A0,
          C0,
          A1,
          C1,
          A2,
          C2,
          A3,
          C3
        >
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<201, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<500, A3, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((createInstitutionProductUserUsingPOSTDefaultResponses as unknown) as CreateInstitutionProductUserUsingPOSTResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3
    >),
    ...(isDecoder(overrideTypes) ? { 201: overrideTypes } : overrideTypes)
  };

  const d201 = (type[201].name === "undefined"
    ? r.constantResponseDecoder<undefined, 201, never>(201, undefined)
    : r.ioResponseDecoder<
        201,
        typeof type[201]["_A"],
        typeof type[201]["_O"],
        never
      >(201, type[201])) as r.ResponseDecoder<r.IResponseType<201, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A3, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(r.composeResponseDecoders(d201, d400), d401),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const createInstitutionProductUserUsingPOSTDefaultDecoder = () =>
  createInstitutionProductUserUsingPOSTDecoder();

/****************************************************************
 * addUserProductRolesUsingPUT
 */

// Request type definition
export type AddUserProductRolesUsingPUTT = r.IPutApiRequestType<
  {
    readonly bearerAuth: string;
    readonly institutionId: string;
    readonly productId: string;
    readonly userId: string;
    readonly body?: UserProductRoles;
  },
  "Content-Type" | "Authorization",
  never,
  | r.IResponseType<201, undefined, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const addUserProductRolesUsingPUTDefaultResponses = {
  201: t.undefined,
  400: Problem,
  401: Problem,
  500: Problem
};

export type AddUserProductRolesUsingPUTResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
> = {
  201: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  500: t.Type<A3, C3>;
};

export function addUserProductRolesUsingPUTDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
>(
  overrideTypes:
    | Partial<
        AddUserProductRolesUsingPUTResponsesT<A0, C0, A1, C1, A2, C2, A3, C3>
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<201, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<500, A3, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((addUserProductRolesUsingPUTDefaultResponses as unknown) as AddUserProductRolesUsingPUTResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3
    >),
    ...(isDecoder(overrideTypes) ? { 201: overrideTypes } : overrideTypes)
  };

  const d201 = (type[201].name === "undefined"
    ? r.constantResponseDecoder<undefined, 201, never>(201, undefined)
    : r.ioResponseDecoder<
        201,
        typeof type[201]["_A"],
        typeof type[201]["_O"],
        never
      >(201, type[201])) as r.ResponseDecoder<r.IResponseType<201, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A3, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(r.composeResponseDecoders(d201, d400), d401),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const addUserProductRolesUsingPUTDefaultDecoder = () =>
  addUserProductRolesUsingPUTDecoder();

/****************************************************************
 * getInstitutionUsersUsingGET
 */

// Request type definition
export type GetInstitutionUsersUsingGETT = r.IGetApiRequestType<
  {
    readonly bearerAuth: string;
    readonly institutionId: string;
    readonly productId?: string;
    readonly role?: string;
    readonly productRoles?: string;
  },
  "Authorization",
  never,
  | r.IResponseType<200, InstitutionUserResourceArray, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<404, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const getInstitutionUsersUsingGETDefaultResponses = {
  200: InstitutionUserResourceArray,
  400: Problem,
  401: Problem,
  404: Problem,
  500: Problem
};

export type GetInstitutionUsersUsingGETResponsesT<
  A0 = InstitutionUserResourceArray,
  C0 = InstitutionUserResourceArray,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  404: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function getInstitutionUsersUsingGETDecoder<
  A0 = InstitutionUserResourceArray,
  C0 = InstitutionUserResourceArray,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
>(
  overrideTypes:
    | Partial<
        GetInstitutionUsersUsingGETResponsesT<
          A0,
          C0,
          A1,
          C1,
          A2,
          C2,
          A3,
          C3,
          A4,
          C4
        >
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<404, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getInstitutionUsersUsingGETDefaultResponses as unknown) as GetInstitutionUsersUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
      d404
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const getInstitutionUsersUsingGETDefaultDecoder = () =>
  getInstitutionUsersUsingGETDecoder();

/****************************************************************
 * getInstitutionUserUsingGET
 */

// Request type definition
export type GetInstitutionUserUsingGETT = r.IGetApiRequestType<
  {
    readonly bearerAuth: string;
    readonly institutionId: string;
    readonly userId: string;
  },
  "Authorization",
  never,
  | r.IResponseType<200, InstitutionUserDetailsResource, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<404, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const getInstitutionUserUsingGETDefaultResponses = {
  200: InstitutionUserDetailsResource,
  400: Problem,
  401: Problem,
  404: Problem,
  500: Problem
};

export type GetInstitutionUserUsingGETResponsesT<
  A0 = InstitutionUserDetailsResource,
  C0 = InstitutionUserDetailsResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  404: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function getInstitutionUserUsingGETDecoder<
  A0 = InstitutionUserDetailsResource,
  C0 = InstitutionUserDetailsResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
>(
  overrideTypes:
    | Partial<
        GetInstitutionUserUsingGETResponsesT<
          A0,
          C0,
          A1,
          C1,
          A2,
          C2,
          A3,
          C3,
          A4,
          C4
        >
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<404, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getInstitutionUserUsingGETDefaultResponses as unknown) as GetInstitutionUserUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
      d404
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const getInstitutionUserUsingGETDefaultDecoder = () =>
  getInstitutionUserUsingGETDecoder();

/****************************************************************
 * getProductRolesUsingGET
 */

// Request type definition
export type GetProductRolesUsingGETT = r.IGetApiRequestType<
  { readonly bearerAuth: string; readonly productId: string },
  "Authorization",
  never,
  | r.IResponseType<200, ProductRoleMappingsResourceArray, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<404, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const getProductRolesUsingGETDefaultResponses = {
  200: ProductRoleMappingsResourceArray,
  400: Problem,
  401: Problem,
  404: Problem,
  500: Problem
};

export type GetProductRolesUsingGETResponsesT<
  A0 = ProductRoleMappingsResourceArray,
  C0 = ProductRoleMappingsResourceArray,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  404: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function getProductRolesUsingGETDecoder<
  A0 = ProductRoleMappingsResourceArray,
  C0 = ProductRoleMappingsResourceArray,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
>(
  overrideTypes:
    | Partial<
        GetProductRolesUsingGETResponsesT<
          A0,
          C0,
          A1,
          C1,
          A2,
          C2,
          A3,
          C3,
          A4,
          C4
        >
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<404, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getProductRolesUsingGETDefaultResponses as unknown) as GetProductRolesUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
      d404
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const getProductRolesUsingGETDefaultDecoder = () =>
  getProductRolesUsingGETDecoder();

/****************************************************************
 * deleteRelationshipByIdUsingDELETE
 */

// Request type definition
export type DeleteRelationshipByIdUsingDELETET = r.IDeleteApiRequestType<
  { readonly bearerAuth: string; readonly relationshipId: string },
  "Authorization",
  never,
  | r.IResponseType<204, undefined, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const deleteRelationshipByIdUsingDELETEDefaultResponses = {
  204: t.undefined,
  400: Problem,
  401: Problem,
  500: Problem
};

export type DeleteRelationshipByIdUsingDELETEResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
> = {
  204: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  500: t.Type<A3, C3>;
};

export function deleteRelationshipByIdUsingDELETEDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
>(
  overrideTypes:
    | Partial<
        DeleteRelationshipByIdUsingDELETEResponsesT<
          A0,
          C0,
          A1,
          C1,
          A2,
          C2,
          A3,
          C3
        >
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<204, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<500, A3, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((deleteRelationshipByIdUsingDELETEDefaultResponses as unknown) as DeleteRelationshipByIdUsingDELETEResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3
    >),
    ...(isDecoder(overrideTypes) ? { 204: overrideTypes } : overrideTypes)
  };

  const d204 = (type[204].name === "undefined"
    ? r.constantResponseDecoder<undefined, 204, never>(204, undefined)
    : r.ioResponseDecoder<
        204,
        typeof type[204]["_A"],
        typeof type[204]["_O"],
        never
      >(204, type[204])) as r.ResponseDecoder<r.IResponseType<204, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A3, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(r.composeResponseDecoders(d204, d400), d401),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const deleteRelationshipByIdUsingDELETEDefaultDecoder = () =>
  deleteRelationshipByIdUsingDELETEDecoder();

/****************************************************************
 * activateRelationshipUsingPOST
 */

// Request type definition
export type ActivateRelationshipUsingPOSTT = r.IPostApiRequestType<
  { readonly bearerAuth: string; readonly relationshipId: string },
  "Content-Type" | "Authorization",
  never,
  | r.IResponseType<204, undefined, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const activateRelationshipUsingPOSTDefaultResponses = {
  204: t.undefined,
  400: Problem,
  401: Problem,
  500: Problem
};

export type ActivateRelationshipUsingPOSTResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
> = {
  204: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  500: t.Type<A3, C3>;
};

export function activateRelationshipUsingPOSTDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
>(
  overrideTypes:
    | Partial<
        ActivateRelationshipUsingPOSTResponsesT<A0, C0, A1, C1, A2, C2, A3, C3>
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<204, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<500, A3, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((activateRelationshipUsingPOSTDefaultResponses as unknown) as ActivateRelationshipUsingPOSTResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3
    >),
    ...(isDecoder(overrideTypes) ? { 204: overrideTypes } : overrideTypes)
  };

  const d204 = (type[204].name === "undefined"
    ? r.constantResponseDecoder<undefined, 204, never>(204, undefined)
    : r.ioResponseDecoder<
        204,
        typeof type[204]["_A"],
        typeof type[204]["_O"],
        never
      >(204, type[204])) as r.ResponseDecoder<r.IResponseType<204, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A3, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(r.composeResponseDecoders(d204, d400), d401),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const activateRelationshipUsingPOSTDefaultDecoder = () =>
  activateRelationshipUsingPOSTDecoder();

/****************************************************************
 * suspendRelationshipUsingPOST
 */

// Request type definition
export type SuspendRelationshipUsingPOSTT = r.IPostApiRequestType<
  { readonly bearerAuth: string; readonly relationshipId: string },
  "Content-Type" | "Authorization",
  never,
  | r.IResponseType<204, undefined, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const suspendRelationshipUsingPOSTDefaultResponses = {
  204: t.undefined,
  400: Problem,
  401: Problem,
  500: Problem
};

export type SuspendRelationshipUsingPOSTResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
> = {
  204: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  500: t.Type<A3, C3>;
};

export function suspendRelationshipUsingPOSTDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
>(
  overrideTypes:
    | Partial<
        SuspendRelationshipUsingPOSTResponsesT<A0, C0, A1, C1, A2, C2, A3, C3>
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<204, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<500, A3, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((suspendRelationshipUsingPOSTDefaultResponses as unknown) as SuspendRelationshipUsingPOSTResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3
    >),
    ...(isDecoder(overrideTypes) ? { 204: overrideTypes } : overrideTypes)
  };

  const d204 = (type[204].name === "undefined"
    ? r.constantResponseDecoder<undefined, 204, never>(204, undefined)
    : r.ioResponseDecoder<
        204,
        typeof type[204]["_A"],
        typeof type[204]["_O"],
        never
      >(204, type[204])) as r.ResponseDecoder<r.IResponseType<204, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A3, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(r.composeResponseDecoders(d204, d400), d401),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const suspendRelationshipUsingPOSTDefaultDecoder = () =>
  suspendRelationshipUsingPOSTDecoder();

/****************************************************************
 * exchangeUsingGET
 */

// Request type definition
export type ExchangeUsingGETT = r.IGetApiRequestType<
  {
    readonly bearerAuth: string;
    readonly institutionId: string;
    readonly productId: string;
  },
  "Authorization",
  never,
  | r.IResponseType<200, IdentityTokenResource, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<404, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const exchangeUsingGETDefaultResponses = {
  200: IdentityTokenResource,
  400: Problem,
  401: Problem,
  404: Problem,
  500: Problem
};

export type ExchangeUsingGETResponsesT<
  A0 = IdentityTokenResource,
  C0 = IdentityTokenResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  404: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function exchangeUsingGETDecoder<
  A0 = IdentityTokenResource,
  C0 = IdentityTokenResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
>(
  overrideTypes:
    | Partial<
        ExchangeUsingGETResponsesT<A0, C0, A1, C1, A2, C2, A3, C3, A4, C4>
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<404, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((exchangeUsingGETDefaultResponses as unknown) as ExchangeUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
      d404
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const exchangeUsingGETDefaultDecoder = () => exchangeUsingGETDecoder();

/****************************************************************
 * getUserGroupsUsingGET
 */

// Request type definition
export type GetUserGroupsUsingGETT = r.IGetApiRequestType<
  {
    readonly bearerAuth: string;
    readonly institutionId?: string;
    readonly page?: number;
    readonly size?: number;
    readonly sort?: Array<string>;
    readonly productId?: string;
    readonly userId?: string;
  },
  "Authorization",
  never,
  | r.IResponseType<200, PageOfUserGroupPlainResource, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<404, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const getUserGroupsUsingGETDefaultResponses = {
  200: PageOfUserGroupPlainResource,
  400: Problem,
  401: Problem,
  404: Problem,
  500: Problem
};

export type GetUserGroupsUsingGETResponsesT<
  A0 = PageOfUserGroupPlainResource,
  C0 = PageOfUserGroupPlainResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  404: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function getUserGroupsUsingGETDecoder<
  A0 = PageOfUserGroupPlainResource,
  C0 = PageOfUserGroupPlainResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
>(
  overrideTypes:
    | Partial<
        GetUserGroupsUsingGETResponsesT<A0, C0, A1, C1, A2, C2, A3, C3, A4, C4>
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<404, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getUserGroupsUsingGETDefaultResponses as unknown) as GetUserGroupsUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
      d404
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const getUserGroupsUsingGETDefaultDecoder = () =>
  getUserGroupsUsingGETDecoder();

/****************************************************************
 * createUserGroupUsingPOST
 */

// Request type definition
export type CreateUserGroupUsingPOSTT = r.IPostApiRequestType<
  { readonly bearerAuth: string; readonly body?: CreateUserGroupDto },
  "Content-Type" | "Authorization",
  never,
  | r.IResponseType<201, UserGroupIdResource, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<409, undefined, never>
  | r.IResponseType<500, Problem, never>
>;

export const createUserGroupUsingPOSTDefaultResponses = {
  201: UserGroupIdResource,
  400: Problem,
  401: Problem,
  409: t.undefined,
  500: Problem
};

export type CreateUserGroupUsingPOSTResponsesT<
  A0 = UserGroupIdResource,
  C0 = UserGroupIdResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = undefined,
  C3 = undefined,
  A4 = Problem,
  C4 = Problem
> = {
  201: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  409: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function createUserGroupUsingPOSTDecoder<
  A0 = UserGroupIdResource,
  C0 = UserGroupIdResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = undefined,
  C3 = undefined,
  A4 = Problem,
  C4 = Problem
>(
  overrideTypes:
    | Partial<
        CreateUserGroupUsingPOSTResponsesT<
          A0,
          C0,
          A1,
          C1,
          A2,
          C2,
          A3,
          C3,
          A4,
          C4
        >
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<201, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<409, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((createUserGroupUsingPOSTDefaultResponses as unknown) as CreateUserGroupUsingPOSTResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 201: overrideTypes } : overrideTypes)
  };

  const d201 = (type[201].name === "undefined"
    ? r.constantResponseDecoder<undefined, 201, never>(201, undefined)
    : r.ioResponseDecoder<
        201,
        typeof type[201]["_A"],
        typeof type[201]["_O"],
        never
      >(201, type[201])) as r.ResponseDecoder<r.IResponseType<201, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d409 = (type[409].name === "undefined"
    ? r.constantResponseDecoder<undefined, 409, never>(409, undefined)
    : r.ioResponseDecoder<
        409,
        typeof type[409]["_A"],
        typeof type[409]["_O"],
        never
      >(409, type[409])) as r.ResponseDecoder<r.IResponseType<409, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d201, d400), d401),
      d409
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const createUserGroupUsingPOSTDefaultDecoder = () =>
  createUserGroupUsingPOSTDecoder();

/****************************************************************
 * deleteUserGroupUsingDELETE
 */

// Request type definition
export type DeleteUserGroupUsingDELETET = r.IDeleteApiRequestType<
  { readonly bearerAuth: string; readonly id: string },
  "Authorization",
  never,
  | r.IResponseType<204, undefined, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const deleteUserGroupUsingDELETEDefaultResponses = {
  204: t.undefined,
  400: Problem,
  401: Problem,
  500: Problem
};

export type DeleteUserGroupUsingDELETEResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
> = {
  204: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  500: t.Type<A3, C3>;
};

export function deleteUserGroupUsingDELETEDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
>(
  overrideTypes:
    | Partial<
        DeleteUserGroupUsingDELETEResponsesT<A0, C0, A1, C1, A2, C2, A3, C3>
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<204, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<500, A3, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((deleteUserGroupUsingDELETEDefaultResponses as unknown) as DeleteUserGroupUsingDELETEResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3
    >),
    ...(isDecoder(overrideTypes) ? { 204: overrideTypes } : overrideTypes)
  };

  const d204 = (type[204].name === "undefined"
    ? r.constantResponseDecoder<undefined, 204, never>(204, undefined)
    : r.ioResponseDecoder<
        204,
        typeof type[204]["_A"],
        typeof type[204]["_O"],
        never
      >(204, type[204])) as r.ResponseDecoder<r.IResponseType<204, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A3, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(r.composeResponseDecoders(d204, d400), d401),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const deleteUserGroupUsingDELETEDefaultDecoder = () =>
  deleteUserGroupUsingDELETEDecoder();

/****************************************************************
 * getUserGroupByIdUsingGET
 */

// Request type definition
export type GetUserGroupByIdUsingGETT = r.IGetApiRequestType<
  {
    readonly bearerAuth: string;
    readonly id: string;
    readonly institutionId?: string;
  },
  "Authorization",
  never,
  | r.IResponseType<200, UserGroupResource, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<404, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const getUserGroupByIdUsingGETDefaultResponses = {
  200: UserGroupResource,
  400: Problem,
  401: Problem,
  404: Problem,
  500: Problem
};

export type GetUserGroupByIdUsingGETResponsesT<
  A0 = UserGroupResource,
  C0 = UserGroupResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  404: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function getUserGroupByIdUsingGETDecoder<
  A0 = UserGroupResource,
  C0 = UserGroupResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
>(
  overrideTypes:
    | Partial<
        GetUserGroupByIdUsingGETResponsesT<
          A0,
          C0,
          A1,
          C1,
          A2,
          C2,
          A3,
          C3,
          A4,
          C4
        >
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<404, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getUserGroupByIdUsingGETDefaultResponses as unknown) as GetUserGroupByIdUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
      d404
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const getUserGroupByIdUsingGETDefaultDecoder = () =>
  getUserGroupByIdUsingGETDecoder();

/****************************************************************
 * updateUserGroupUsingPUT
 */

// Request type definition
export type UpdateUserGroupUsingPUTT = r.IPutApiRequestType<
  {
    readonly bearerAuth: string;
    readonly id: string;
    readonly body?: UpdateUserGroupDto;
  },
  "Content-Type" | "Authorization",
  never,
  | r.IResponseType<204, undefined, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<409, undefined, never>
  | r.IResponseType<500, Problem, never>
>;

export const updateUserGroupUsingPUTDefaultResponses = {
  204: t.undefined,
  400: Problem,
  401: Problem,
  409: t.undefined,
  500: Problem
};

export type UpdateUserGroupUsingPUTResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = undefined,
  C3 = undefined,
  A4 = Problem,
  C4 = Problem
> = {
  204: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  409: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function updateUserGroupUsingPUTDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = undefined,
  C3 = undefined,
  A4 = Problem,
  C4 = Problem
>(
  overrideTypes:
    | Partial<
        UpdateUserGroupUsingPUTResponsesT<
          A0,
          C0,
          A1,
          C1,
          A2,
          C2,
          A3,
          C3,
          A4,
          C4
        >
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<204, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<409, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((updateUserGroupUsingPUTDefaultResponses as unknown) as UpdateUserGroupUsingPUTResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 204: overrideTypes } : overrideTypes)
  };

  const d204 = (type[204].name === "undefined"
    ? r.constantResponseDecoder<undefined, 204, never>(204, undefined)
    : r.ioResponseDecoder<
        204,
        typeof type[204]["_A"],
        typeof type[204]["_O"],
        never
      >(204, type[204])) as r.ResponseDecoder<r.IResponseType<204, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d409 = (type[409].name === "undefined"
    ? r.constantResponseDecoder<undefined, 409, never>(409, undefined)
    : r.ioResponseDecoder<
        409,
        typeof type[409]["_A"],
        typeof type[409]["_O"],
        never
      >(409, type[409])) as r.ResponseDecoder<r.IResponseType<409, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d204, d400), d401),
      d409
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const updateUserGroupUsingPUTDefaultDecoder = () =>
  updateUserGroupUsingPUTDecoder();

/****************************************************************
 * activateUserGroupUsingPOST
 */

// Request type definition
export type ActivateUserGroupUsingPOSTT = r.IPostApiRequestType<
  { readonly bearerAuth: string; readonly id: string },
  "Content-Type" | "Authorization",
  never,
  | r.IResponseType<204, undefined, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const activateUserGroupUsingPOSTDefaultResponses = {
  204: t.undefined,
  400: Problem,
  401: Problem,
  500: Problem
};

export type ActivateUserGroupUsingPOSTResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
> = {
  204: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  500: t.Type<A3, C3>;
};

export function activateUserGroupUsingPOSTDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
>(
  overrideTypes:
    | Partial<
        ActivateUserGroupUsingPOSTResponsesT<A0, C0, A1, C1, A2, C2, A3, C3>
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<204, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<500, A3, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((activateUserGroupUsingPOSTDefaultResponses as unknown) as ActivateUserGroupUsingPOSTResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3
    >),
    ...(isDecoder(overrideTypes) ? { 204: overrideTypes } : overrideTypes)
  };

  const d204 = (type[204].name === "undefined"
    ? r.constantResponseDecoder<undefined, 204, never>(204, undefined)
    : r.ioResponseDecoder<
        204,
        typeof type[204]["_A"],
        typeof type[204]["_O"],
        never
      >(204, type[204])) as r.ResponseDecoder<r.IResponseType<204, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A3, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(r.composeResponseDecoders(d204, d400), d401),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const activateUserGroupUsingPOSTDefaultDecoder = () =>
  activateUserGroupUsingPOSTDecoder();

/****************************************************************
 * addMemberToUserGroupUsingPOST
 */

// Request type definition
export type AddMemberToUserGroupUsingPOSTT = r.IPostApiRequestType<
  { readonly bearerAuth: string; readonly id: string; readonly userId: string },
  "Content-Type" | "Authorization",
  never,
  | r.IResponseType<204, undefined, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const addMemberToUserGroupUsingPOSTDefaultResponses = {
  204: t.undefined,
  400: Problem,
  401: Problem,
  500: Problem
};

export type AddMemberToUserGroupUsingPOSTResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
> = {
  204: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  500: t.Type<A3, C3>;
};

export function addMemberToUserGroupUsingPOSTDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
>(
  overrideTypes:
    | Partial<
        AddMemberToUserGroupUsingPOSTResponsesT<A0, C0, A1, C1, A2, C2, A3, C3>
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<204, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<500, A3, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((addMemberToUserGroupUsingPOSTDefaultResponses as unknown) as AddMemberToUserGroupUsingPOSTResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3
    >),
    ...(isDecoder(overrideTypes) ? { 204: overrideTypes } : overrideTypes)
  };

  const d204 = (type[204].name === "undefined"
    ? r.constantResponseDecoder<undefined, 204, never>(204, undefined)
    : r.ioResponseDecoder<
        204,
        typeof type[204]["_A"],
        typeof type[204]["_O"],
        never
      >(204, type[204])) as r.ResponseDecoder<r.IResponseType<204, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A3, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(r.composeResponseDecoders(d204, d400), d401),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const addMemberToUserGroupUsingPOSTDefaultDecoder = () =>
  addMemberToUserGroupUsingPOSTDecoder();

/****************************************************************
 * suspendUserGroupUsingPOST
 */

// Request type definition
export type SuspendUserGroupUsingPOSTT = r.IPostApiRequestType<
  { readonly bearerAuth: string; readonly id: string },
  "Content-Type" | "Authorization",
  never,
  | r.IResponseType<204, undefined, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const suspendUserGroupUsingPOSTDefaultResponses = {
  204: t.undefined,
  400: Problem,
  401: Problem,
  500: Problem
};

export type SuspendUserGroupUsingPOSTResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
> = {
  204: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  500: t.Type<A3, C3>;
};

export function suspendUserGroupUsingPOSTDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
>(
  overrideTypes:
    | Partial<
        SuspendUserGroupUsingPOSTResponsesT<A0, C0, A1, C1, A2, C2, A3, C3>
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<204, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<500, A3, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((suspendUserGroupUsingPOSTDefaultResponses as unknown) as SuspendUserGroupUsingPOSTResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3
    >),
    ...(isDecoder(overrideTypes) ? { 204: overrideTypes } : overrideTypes)
  };

  const d204 = (type[204].name === "undefined"
    ? r.constantResponseDecoder<undefined, 204, never>(204, undefined)
    : r.ioResponseDecoder<
        204,
        typeof type[204]["_A"],
        typeof type[204]["_O"],
        never
      >(204, type[204])) as r.ResponseDecoder<r.IResponseType<204, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A3, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(r.composeResponseDecoders(d204, d400), d401),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const suspendUserGroupUsingPOSTDefaultDecoder = () =>
  suspendUserGroupUsingPOSTDecoder();

/****************************************************************
 * deleteMemberFromUserGroupUsingDELETE
 */

// Request type definition
export type DeleteMemberFromUserGroupUsingDELETET = r.IDeleteApiRequestType<
  {
    readonly bearerAuth: string;
    readonly userGroupId: string;
    readonly userId: string;
  },
  "Authorization",
  never,
  | r.IResponseType<204, undefined, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const deleteMemberFromUserGroupUsingDELETEDefaultResponses = {
  204: t.undefined,
  400: Problem,
  401: Problem,
  500: Problem
};

export type DeleteMemberFromUserGroupUsingDELETEResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
> = {
  204: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  500: t.Type<A3, C3>;
};

export function deleteMemberFromUserGroupUsingDELETEDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
>(
  overrideTypes:
    | Partial<
        DeleteMemberFromUserGroupUsingDELETEResponsesT<
          A0,
          C0,
          A1,
          C1,
          A2,
          C2,
          A3,
          C3
        >
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<204, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<500, A3, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((deleteMemberFromUserGroupUsingDELETEDefaultResponses as unknown) as DeleteMemberFromUserGroupUsingDELETEResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3
    >),
    ...(isDecoder(overrideTypes) ? { 204: overrideTypes } : overrideTypes)
  };

  const d204 = (type[204].name === "undefined"
    ? r.constantResponseDecoder<undefined, 204, never>(204, undefined)
    : r.ioResponseDecoder<
        204,
        typeof type[204]["_A"],
        typeof type[204]["_O"],
        never
      >(204, type[204])) as r.ResponseDecoder<r.IResponseType<204, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A3, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(r.composeResponseDecoders(d204, d400), d401),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const deleteMemberFromUserGroupUsingDELETEDefaultDecoder = () =>
  deleteMemberFromUserGroupUsingDELETEDecoder();

/****************************************************************
 * saveUserUsingPOST
 */

// Request type definition
export type SaveUserUsingPOSTT = r.IPostApiRequestType<
  {
    readonly bearerAuth: string;
    readonly institutionId: string;
    readonly body?: UserDto;
  },
  "Content-Type" | "Authorization",
  never,
  | r.IResponseType<201, UserIdResource, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const saveUserUsingPOSTDefaultResponses = {
  201: UserIdResource,
  400: Problem,
  401: Problem,
  500: Problem
};

export type SaveUserUsingPOSTResponsesT<
  A0 = UserIdResource,
  C0 = UserIdResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
> = {
  201: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  500: t.Type<A3, C3>;
};

export function saveUserUsingPOSTDecoder<
  A0 = UserIdResource,
  C0 = UserIdResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
>(
  overrideTypes:
    | Partial<SaveUserUsingPOSTResponsesT<A0, C0, A1, C1, A2, C2, A3, C3>>
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<201, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<500, A3, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((saveUserUsingPOSTDefaultResponses as unknown) as SaveUserUsingPOSTResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3
    >),
    ...(isDecoder(overrideTypes) ? { 201: overrideTypes } : overrideTypes)
  };

  const d201 = (type[201].name === "undefined"
    ? r.constantResponseDecoder<undefined, 201, never>(201, undefined)
    : r.ioResponseDecoder<
        201,
        typeof type[201]["_A"],
        typeof type[201]["_O"],
        never
      >(201, type[201])) as r.ResponseDecoder<r.IResponseType<201, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A3, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(r.composeResponseDecoders(d201, d400), d401),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const saveUserUsingPOSTDefaultDecoder = () => saveUserUsingPOSTDecoder();

/****************************************************************
 * searchUsingPOST
 */

// Request type definition
export type SearchUsingPOSTT = r.IPostApiRequestType<
  {
    readonly bearerAuth: string;
    readonly institutionId: string;
    readonly body?: SearchUserDto;
  },
  "Content-Type" | "Authorization",
  never,
  | r.IResponseType<200, UserResource, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<404, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const searchUsingPOSTDefaultResponses = {
  200: UserResource,
  400: Problem,
  401: Problem,
  404: Problem,
  500: Problem
};

export type SearchUsingPOSTResponsesT<
  A0 = UserResource,
  C0 = UserResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  404: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function searchUsingPOSTDecoder<
  A0 = UserResource,
  C0 = UserResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
>(
  overrideTypes:
    | Partial<SearchUsingPOSTResponsesT<A0, C0, A1, C1, A2, C2, A3, C3, A4, C4>>
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<404, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((searchUsingPOSTDefaultResponses as unknown) as SearchUsingPOSTResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
      d404
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const searchUsingPOSTDefaultDecoder = () => searchUsingPOSTDecoder();

/****************************************************************
 * deleteUserByIdUsingDELETE
 */

// Request type definition
export type DeleteUserByIdUsingDELETET = r.IDeleteApiRequestType<
  { readonly bearerAuth: string; readonly id: string },
  "Authorization",
  never,
  | r.IResponseType<204, undefined, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const deleteUserByIdUsingDELETEDefaultResponses = {
  204: t.undefined,
  400: Problem,
  401: Problem,
  500: Problem
};

export type DeleteUserByIdUsingDELETEResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
> = {
  204: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  500: t.Type<A3, C3>;
};

export function deleteUserByIdUsingDELETEDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
>(
  overrideTypes:
    | Partial<
        DeleteUserByIdUsingDELETEResponsesT<A0, C0, A1, C1, A2, C2, A3, C3>
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<204, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<500, A3, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((deleteUserByIdUsingDELETEDefaultResponses as unknown) as DeleteUserByIdUsingDELETEResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3
    >),
    ...(isDecoder(overrideTypes) ? { 204: overrideTypes } : overrideTypes)
  };

  const d204 = (type[204].name === "undefined"
    ? r.constantResponseDecoder<undefined, 204, never>(204, undefined)
    : r.ioResponseDecoder<
        204,
        typeof type[204]["_A"],
        typeof type[204]["_O"],
        never
      >(204, type[204])) as r.ResponseDecoder<r.IResponseType<204, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A3, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(r.composeResponseDecoders(d204, d400), d401),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const deleteUserByIdUsingDELETEDefaultDecoder = () =>
  deleteUserByIdUsingDELETEDecoder();

/****************************************************************
 * getUserByInternalIdUsingGET
 */

// Request type definition
export type GetUserByInternalIdUsingGETT = r.IGetApiRequestType<
  {
    readonly bearerAuth: string;
    readonly id: string;
    readonly institutionId: string;
  },
  "Authorization",
  never,
  | r.IResponseType<200, UserResource, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<404, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const getUserByInternalIdUsingGETDefaultResponses = {
  200: UserResource,
  400: Problem,
  401: Problem,
  404: Problem,
  500: Problem
};

export type GetUserByInternalIdUsingGETResponsesT<
  A0 = UserResource,
  C0 = UserResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  404: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function getUserByInternalIdUsingGETDecoder<
  A0 = UserResource,
  C0 = UserResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
>(
  overrideTypes:
    | Partial<
        GetUserByInternalIdUsingGETResponsesT<
          A0,
          C0,
          A1,
          C1,
          A2,
          C2,
          A3,
          C3,
          A4,
          C4
        >
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<404, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getUserByInternalIdUsingGETDefaultResponses as unknown) as GetUserByInternalIdUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
      d404
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const getUserByInternalIdUsingGETDefaultDecoder = () =>
  getUserByInternalIdUsingGETDecoder();

/****************************************************************
 * updateUserUsingPUT
 */

// Request type definition
export type UpdateUserUsingPUTT = r.IPutApiRequestType<
  {
    readonly bearerAuth: string;
    readonly id: string;
    readonly institutionId: string;
    readonly body?: UpdateUserDto;
  },
  "Content-Type" | "Authorization",
  never,
  | r.IResponseType<204, undefined, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const updateUserUsingPUTDefaultResponses = {
  204: t.undefined,
  400: Problem,
  401: Problem,
  500: Problem
};

export type UpdateUserUsingPUTResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
> = {
  204: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  500: t.Type<A3, C3>;
};

export function updateUserUsingPUTDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
>(
  overrideTypes:
    | Partial<UpdateUserUsingPUTResponsesT<A0, C0, A1, C1, A2, C2, A3, C3>>
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<204, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<500, A3, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((updateUserUsingPUTDefaultResponses as unknown) as UpdateUserUsingPUTResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3
    >),
    ...(isDecoder(overrideTypes) ? { 204: overrideTypes } : overrideTypes)
  };

  const d204 = (type[204].name === "undefined"
    ? r.constantResponseDecoder<undefined, 204, never>(204, undefined)
    : r.ioResponseDecoder<
        204,
        typeof type[204]["_A"],
        typeof type[204]["_O"],
        never
      >(204, type[204])) as r.ResponseDecoder<r.IResponseType<204, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A3, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(r.composeResponseDecoders(d204, d400), d401),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const updateUserUsingPUTDefaultDecoder = () =>
  updateUserUsingPUTDecoder();
